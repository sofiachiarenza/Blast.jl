var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"# Types\nBlast.FlatΛCDM\nBlast.BackgroundQuantities\nBlast.AbstractCosmology\nBlast.AbstractBackgroundQuantities\nBlast.AbstractCosmologicalGrid\nBlast.AbstractCosmologicalProbes\nBlast.CosmologicalGrid\nBlast.GalaxyKernel\nBlast.ShearKernel\nBlast.CMBLensingKernel\n\n# Functions\nBlast.compute_T̃\nBlast.bessel_cheb_eval\nBlast.get_clencurt_weights\nBlast.get_clencurt_grid\nBlast.w_ell_tullio\nBlast.plan_fft\nBlast.fast_chebcoefs\nBlast.make_grid\nBlast.grid_interpolator(::Union{Blast.GalaxyKernel, Blast.ShearKernel},::Blast.BackgroundQuantities, ::Vector{T}) where T\nBlast.grid_interpolator(::Blast.CMBLensingKernel, ::Blast.BackgroundQuantities, ::Vector{T}) where T\nBlast.get_kernel_array(::Blast.GalaxyKernel, ::Blast.BackgroundQuantities, ::Vector{T}) where T\nBlast.get_kernel_array(::Blast.ShearKernel, ::Blast.BackgroundQuantities, ::Vector{T}) where T\nBlast.get_kernel_array(::Blast.CMBLensingKernel, ::Blast.BackgroundQuantities, ::Vector{T}) where T\nBlast.combine_kernels\nBlast.factorial_frac\nBlast.get_ell_prefactor(::Blast.GalaxyKernel, ::Blast.GalaxyKernel, ::Vector)\nBlast.get_ell_prefactor(::Blast.GalaxyKernel, ::Blast.ShearKernel, ::Vector)\nBlast.get_ell_prefactor(::Blast.ShearKernel, ::Blast.ShearKernel, ::Vector)\nBlast.get_ell_prefactor(::Blast.CMBLensingKernel, ::Blast.ShearKernel, ::Vector)\nBlast.get_ell_prefactor(::Blast.CMBLensingKernel, ::Blast.CMBLensingKernel, ::Vector)\nBlast.get_ell_prefactor(::Blast.CMBLensingKernel, ::Blast.GalaxyKernel, ::Vector)\nBlast.simpson_weight_array\nBlast.get_clencurt_weights_R_integration\nBlast.compute_Cℓ(::AbstractArray{T, 3}, \n               ::Union{Blast.GalaxyKernel, Blast.ShearKernel, Blast.CMBLensingKernel}, \n               ::Union{Blast.GalaxyKernel, Blast.ShearKernel, Blast.CMBLensingKernel}, \n               ::Blast.BackgroundQuantities, \n               R::AbstractVector, \n               ℓ_list::AbstractArray{T,1} = Blast.ℓ) where T\nBlast.compute_Cℓ(::AbstractArray{T, 3}, \n               ::AbstractArray{T, 4}, \n               ::Blast.BackgroundQuantities, \n               ::AbstractArray{T, 1}, \n               ::AbstractArray{T, 1}, \n               ::AbstractArray{T,1}) where T\nBlast.compute_adimensional_hubble_factor(::T, ::Blast.FlatΛCDM) where T\nBlast.compute_adimensional_hubble_factor(::T, ::T, ::T, ::T, ::T, ::T, ::T) where T\nBlast.compute_hubble_factor\nBlast.compute_χ\nBlast.evaluate_background_quantities!\nBlast.resample_redshifts\nBlast.compute_kernel!(::AbstractArray{T, 2}, ::AbstractArray{T, 1}, ::Blast.GalaxyKernel, ::AbstractArray{T, 1}, ::Blast.CosmologicalGrid, ::Blast.BackgroundQuantities, ::Blast.AbstractCosmology) where T\nBlast.compute_kernel!(::AbstractArray{T, 2}, ::AbstractArray{T, 1}, ::Blast.GalaxyKernel, ::AbstractArray{T, 2}, ::Blast.CosmologicalGrid, ::Blast.BackgroundQuantities, ::Blast.AbstractCosmology) where T\nBlast.compute_kernel!(::AbstractArray{T, 2}, ::AbstractArray{T, 1}, ::Blast.ShearKernel, ::Blast.CosmologicalGrid, ::Blast.BackgroundQuantities, ::Blast.AbstractCosmology) where T\nBlast.compute_kernel!(::Blast.CMBLensingKernel, ::Blast.CosmologicalGrid, ::Blast.BackgroundQuantities, ::Blast.AbstractCosmology)\nBlast.chebyshev_polynomials\nBlast.interpolate_power_spectrum\nBlast.unequal_time_power_spectrum","category":"page"},{"location":"api/#Blast.FlatΛCDM","page":"API","title":"Blast.FlatΛCDM","text":"FlatΛCDM{T}(; w0 = -1.0, wa = 0.0, H0 = 67.27, Ωm = 0.3156, Ωb = 0.0492, \n    Ωde = 0.6844, As = 2.12107e-9, σ8 = 0.816, Ωk = 0.0, Ωr = 0.0, ns = 0.9645\n)\n\nParameters:\n\nw0: Dark energy equation of state parameter at present time (default: -1).\nwa: Time evolution of the dark energy equation of state (default: 0).\nH0: Hubble constant in km/s/Mpc (default: 67.27).\nΩm: Matter density parameter (default: 0.3156).\nΩb: Baryon density parameter (default: 0.0492).\nΩde: Dark energy density parameter (default: 0.6844).\nAs: Scalar amplitude of the primordial power spectrum (default: 2.12107e-9).\nσ8: Root-mean-square density fluctuation in spheres of radius 8 Mpc (default: 0.816).\nΩk: Curvature density parameter (default: 0, for flat universe).\nΩr: Radiation density parameter (default: 0, since radiation is negligible at low redshift).\nns: Scalar spectral index (default: 0.9645).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.BackgroundQuantities","page":"API","title":"Blast.BackgroundQuantities","text":"BackgroundQuantities{T}(; Hz_array, χz_array)\n\nParameters:\n\nHz_array: Array of Hubble parameter values, evaluated on a grid of redshift values (default: zeros(500)).\nχz_array: Array of comoving distance values, evaluated on a grid of redshift values (default: zeros(500)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmology","page":"API","title":"Blast.AbstractCosmology","text":"AbstractCosmology{T}\n\nAn abstract type representing a general cosmological model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractBackgroundQuantities","page":"API","title":"Blast.AbstractBackgroundQuantities","text":"AbstractBackgroundQuantities{T}\n\nAn abstract type for background quantities in cosmology, such as the Hubble parameter (H), comoving distance (χ),  and the growth factor (D).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmologicalGrid","page":"API","title":"Blast.AbstractCosmologicalGrid","text":"AbstractCosmologicalGrid{T}\n\nAn abstract type representing a grid on which cosmological quantities are evaluated.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmologicalProbes","page":"API","title":"Blast.AbstractCosmologicalProbes","text":"AbstractCosmologicalProbes{T}\n\nAn abstract type for the shear, clustering and CMB lensing kernels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.CosmologicalGrid","page":"API","title":"Blast.CosmologicalGrid","text":"CosmologicalGrid{T}(; z_range, k_range)\n\nParameters:\n\nz_range: Array of redshift values where quantities like the Hubble parameter are evaluated (default: LinRange(0.001, 2.5, 300)).\nk_range: Array of wavenumbers for evaluating power spectra or other k-dependent quantities (default: LogSpaced(1e-5, 50, 1000)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.GalaxyKernel","page":"API","title":"Blast.GalaxyKernel","text":"GalaxyKernel{T} <: AbstractCosmologicalProbes{T}\n\nRepresents a galaxy kernel in cosmological calculations, where kernel values are provided for multiple tomographic bins.\n\nParameters\n\nKernel::AbstractArray{T, 2}: A 2D array of type T, with dimensions (n_bins, nχ). This stores kernel values for each tomographic bin and a grid of χ values.\n\nConstructors\n\nGalaxyKernel{T}(n_bins::Int, nχ::Int): Creates a GalaxyKernel with the specified n_bins and nχ values, initializing the kernel values to zeros of type T.\nGalaxyKernel(n_bins::Int, nχ::Int): Creates a GalaxyKernel with the specified n_bins and nχ values, initializing the kernel values to zeros of type Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.ShearKernel","page":"API","title":"Blast.ShearKernel","text":"ShearKernel{T} <: AbstractCosmologicalProbes{T}\n\nRepresents a shear kernel used in cosmological lensing calculations. The kernel is defined over multiple tomographic bins.\n\nParameters\n\nKernel::AbstractArray{T, 2}: A 2D array of type T, with dimensions (n_bins, nχ). Stores the kernel values for each tomographic bin and a grid of χ values.\n\nConstructors\n\nShearKernel{T}(n_bins::Int, nχ::Int): Creates a ShearKernel with the specified n_bins and nχ values, initializing the kernel values to zeros of type T.\nShearKernel(n_bins::Int, nχ::Int): Creates a ShearKernel with the specified n_bins and nχ values, initializing the kernel values to zeros of type Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.CMBLensingKernel","page":"API","title":"Blast.CMBLensingKernel","text":"CMBLensingKernel{T} <: AbstractCosmologicalProbes{T}\n\nRepresents a CMB lensing kernel.\n\nParameters\n\nKernel::AbstractArray{T, 1}: A 1D array of type T, with dimension (nχ). Note that CMB Lensing by definition only has a single tomographic bin.\n\nConstructors\n\nCMBLensingKernel{T}(nχ::Int): Creates a CMBLensingKernel with the specified nχ value, initializing the kernel values to zeros of type T.\nCMBLensingKernel(nχ::Int): Creates a CMBLensingKernel with the specified nχ value, initializing the kernel values to zeros of type Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.compute_T̃","page":"API","title":"Blast.compute_T̃","text":"compute_T̃(ℓ::Number, χ::AbstractArray, R::AbstractArray, kmin::Number, kmax::Number, β::Number; n_cheb::Int = 119, N::Int = 2^(15)+1)\n\nCompute integrals of the Bessels function and the Chebyshev polynomials. This is the precomputation part of the code.\n\nArguments\n\nℓ::Number: Multipole order\nχ::AbstractArray: Array containing values of the comoving distance. \nR::AbstractArray: Array containing values for the R=χ₁/χ₂ variable.\nkmin::Number and kmax::Number: Integration range in k.\nβ::Number: Exponent of the k dependence of the integral. This parameter depends on the combination of tracers: β=2,-2,0 for clustering, cosmic shear and the cross-correlation respectively.\nn_cheb::Int: Number of chebyshev polynomials used in the approximation of the power spectra.\nN::Int: Number of integration points in k.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.bessel_cheb_eval","page":"API","title":"Blast.bessel_cheb_eval","text":"bessel_cheb_eval(ℓ::Number, kmin::Number, kmax::Number, χ::AbstractArray, n_cheb::Int, N::Number)\n\nReturn the Chebyshev polynomials up to order 'n_cheb+1' and the Bessel function of order 'ℓ' evaluated on the grid of 'N' Chebyshev points in the interval ['kmin', 'kmax'] and on the specified 'χ' points. \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_weights","page":"API","title":"Blast.get_clencurt_weights","text":"get_clencurt_weights(kmin::Number, kmax::Number, N::Number)\n\nReturn the set of 'N' weights needed to perform the integration with the Clenshaw-Curtis quadrature rule. The weights are rescaled between 'kmin' and 'kmax'.  \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_grid","page":"API","title":"Blast.get_clencurt_grid","text":"get_clencurt_grid(kmin::Number, kmax::Number, N::Number)\n\nReturn the integration points in k. They are a set of 'N' Chebyshev points rescaled between 'kmin' and 'kmax'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.w_ell_tullio","page":"API","title":"Blast.w_ell_tullio","text":"w_ell_tullio(c::AbstractArray,T::AbstractArray)\n\nCompute the tensor contraction of the chebyshev coefficients of the power spectrum 'c' and the precomputed integrals 'T' to obtain the projected matter densities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.plan_fft","page":"API","title":"Blast.plan_fft","text":"plan_fft(vals::AbstractArray{<:Number, N}, axis::Int)\n\nCreate an FFTW real-to-real (R2R) transformation plan for a specified axis of a given multidimensional array vals.  For example, if the vals array is the power spectrum P(k,z), one can set axis=1 and perform the FFT in k, or axis=2 if the FFT is to be performed along z.\n\nArguments\n\nvals::AbstractArray{<:Number, N}: The input array of any numerical type with N dimensions.\naxis::Int: The axis along which the FFT transformation will be applied (e.g., 1 for the first axis, 2 for the second axis, etc.).\n\nReturns\n\np::FFTW.rFFTWPlan: An FFTW plan object for transforming vals with the appropriate real-to-real transformations. This plan can be applied using the * operator (e.g., transformed_vals = p * vals).\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.fast_chebcoefs","page":"API","title":"Blast.fast_chebcoefs","text":"fast_chebcoefs(vals::AbstractArray{<:Number,N}, plan::FFTW.r2rFFTWPlan)\n\nEfficiently compute the Chebyshev coefficients of a multidimensional array vals using an O(n log n) method. This method leverages FFT-based type-I Discrete Cosine Transform (DCT-I).\n\nArguments:\n\nvals::AbstractArray{<:Number,N}: A multidimensional array of values for which to compute the Chebyshev coefficients.\nplan::FFTW.r2rFFTWPlan: A FFTW plan object for transforming vals with the appropriate real to real transformations. This plan is applied using the * operator (e.g., transformed_vals = p * vals) and performs the DCT of the vals array along the first axis.\n\nReturns:\n\ncoefs: An array of the same size as vals, containing the computed Chebyshev coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.make_grid","page":"API","title":"Blast.make_grid","text":"make_grid(BackgroundQuantities::BackgroundQuantities, R::Vector{T}) where T\n\nConstructs a grid by multiplying the χz_array from BackgroundQuantities with the vector R.\n\nArguments\n\nBackgroundQuantities::BackgroundQuantities: An instance of the BackgroundQuantities type that contains the χz_array.\nR::Vector{T}: A vector of values to be used in the grid construction, where T can be any type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.grid_interpolator-Union{Tuple{T}, Tuple{Union{Blast.GalaxyKernel, Blast.ShearKernel}, Blast.BackgroundQuantities, Vector{T}}} where T","page":"API","title":"Blast.grid_interpolator","text":"grid_interpolator(Probe::Union{GalaxyKernel, ShearKernel}, \n    BackgroundQuantities::BackgroundQuantities, grid::Vector{T}) where T\n\nInterpolates the kernel values for a given grid based on the specified cosmological probes.  Returns a 2D array of interpolated kernel values, where rows correspond to the number of bins and columns correspond to the grid points.\n\nArguments\n\nProbe::Union{GalaxyKernel, ShearKernel}: The kernel data to be interpolated.\nBackgroundQuantities::BackgroundQuantities: An instance of the BackgroundQuantities type that contains the χz_array.\ngrid::Vector{T}: A vector of values where the interpolated kernel values will be evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.grid_interpolator-Union{Tuple{T}, Tuple{Blast.CMBLensingKernel, Blast.BackgroundQuantities, Vector{T}}} where T","page":"API","title":"Blast.grid_interpolator","text":"grid_interpolator(Probe::CMBLensingKernel, \n    bg::BackgroundQuantities, grid::Vector{T}) where T\n\nInterpolates the kernel values for a given grid based on the specified cosmological probes.  Returns a 2D array of interpolated kernel values, where rows correspond to the number of bins and columns correspond to the grid points.\n\nArguments\n\nProbe::CMBLensingKernel: The kernel data to be interpolated.\nbg::BackgroundQuantities: An instance of the BackgroundQuantities type that contains the χz_array.\ngrid::Vector{T}: A vector of values where the interpolated kernel values will be evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_kernel_array-Union{Tuple{T}, Tuple{Blast.GalaxyKernel, Blast.BackgroundQuantities, Vector{T}}} where T","page":"API","title":"Blast.get_kernel_array","text":"get_kernel_array(AbstractCosmologicalProbes::GalaxyKernel, \n    BackgroundQuantities::BackgroundQuantities, R::Vector{T}) where T\n\nObtains the kernel array for the GalaxyKernel probe, with dimensions (bins, nχ, nR). \n\nArguments\n\nAbstractCosmologicalProbes::GalaxyKernel: An instance of the GalaxyKernel type.\nBackgroundQuantities::BackgroundQuantities: An instance of the BackgroundQuantities type.\nR::Vector{T}: A vector of values for which the kernel array is to be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_kernel_array-Union{Tuple{T}, Tuple{Blast.ShearKernel, Blast.BackgroundQuantities, Vector{T}}} where T","page":"API","title":"Blast.get_kernel_array","text":"get_kernel_array(Probe::ShearKernel, \n    bg::BackgroundQuantities, R::Vector{T}) where T\n\nObtains the kernel array for the weak lensing probe, with dimensions (bins, nχ, nR) The difference with respect to the galaxy case is that these kernels are divided by chi^2.\n\nArguments\n\nProbe::ShearKernel: An instance of ShearKernel.\nbg::BackgroundQuantities: An instance of the BackgroundQuantities type.\nR::Vector{T}: A vector of values for which the kernel array is to be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_kernel_array-Union{Tuple{T}, Tuple{Blast.CMBLensingKernel, Blast.BackgroundQuantities, Vector{T}}} where T","page":"API","title":"Blast.get_kernel_array","text":"get_kernel_array(Probe::CMBLensingKernel, \n    bg::BackgroundQuantities, R::Vector{T}) where T\n\nObtains the kernel array for the CMB lensing probe, with dimensions (1, nχ, nR) Similarly to the weak lensing case, the kernel is divided by chi^2.\n\nArguments\n\nProbe::CMBLensingKernel: An instance of CMBLensingKernel.\nbg::BackgroundQuantities: An instance of the BackgroundQuantities type.\nR::Vector{T}: A vector of values for which the kernel array is to be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.combine_kernels","page":"API","title":"Blast.combine_kernels","text":"combine_kernels(ProbeA::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}, \n    ProbeB::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}, \n    BackgroundQuantities::BackgroundQuantities, R::Vector{T}) where T\n\nCombines the kernels from two different cosmological probes into a single array.  This is needed to perform the integration in the χ-R coordinates.\n\nArguments\n\nProbeA::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}: The first cosmological probe to combine.\nProbeB::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}: The second cosmological probe to combine.\nBackgroundQuantities::BackgroundQuantities: An instance of the BackgroundQuantities type.\nR::Vector{T}: A vector of values used in the combination.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.factorial_frac","page":"API","title":"Blast.factorial_frac","text":"factorial_frac(ℓ::Union{Number,Vector{T}}}) where T\n\nComputes the ratio (ℓ+2)!/(ℓ-2)!, needed in the pre-factors of the the angular power spectra.\n\nArguments\n\nℓ::Vector{T}: vectors of ℓ values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.GalaxyKernel, Blast.GalaxyKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::GalaxyKernel, ProbeB::GalaxyKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when both probes are GalaxyKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.GalaxyKernel, Blast.ShearKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::GalaxyKernel, ProbeB::ShearKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when probes are GalaxyKernel and ShearKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.ShearKernel, Blast.ShearKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::ShearKernel, ProbeB::ShearKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when both probes are ShearKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.CMBLensingKernel, Blast.ShearKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::CMBLensingKernel, ProbeB::ShearKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when probes are CMBLensingKernel and ShearKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.CMBLensingKernel, Blast.CMBLensingKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::CMBLensingKernel, ProbeB::CMBLensingKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when both probes are CMBLensingKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.get_ell_prefactor-Tuple{Blast.CMBLensingKernel, Blast.GalaxyKernel, Vector}","page":"API","title":"Blast.get_ell_prefactor","text":"get_ell_prefactor(ProbeA::CMBLensingKernel, ProbeB::GalaxyKernel, ℓ_list::Vector)\n\nCalculates the prefactor for the angular power spectrum when probes are CMBLensingKernel and GalaxyKernel.\n\nArguments\n\nℓ_list::Vector: A vector of angular multipole values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.simpson_weight_array","page":"API","title":"Blast.simpson_weight_array","text":"simpson_weight_array(n::Int; T=Float64)\n\nComputes the weights for the Simpson quadrature rule for numerical integration based on the input number of points n.\n\nArguments\n\nn::Int: The number of points (must be at least 2).\nT: (optional) The type of the output array. Defaults to Float64.\n\nReturns\n\nAn array of length n with the weights of type T for the Simpson quadrature rule.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_weights_R_integration","page":"API","title":"Blast.get_clencurt_weights_R_integration","text":"get_clencurt_weights_R_integration(N::Int)\n\nCalculate Clenshaw-Curtis quadrature weights for numerical integration over a given interval. The weights are computed for the second half of the Chebyshev points, omitting the zero element.  The first weight is halved, although this is an approximation and may benefit from further optimization.\n\nArguments\n\nN::Int: The number of quadrature points.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_Cℓ-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Union{Blast.CMBLensingKernel, Blast.GalaxyKernel, Blast.ShearKernel}, Union{Blast.CMBLensingKernel, Blast.GalaxyKernel, Blast.ShearKernel}, Blast.BackgroundQuantities, AbstractVector}, Tuple{AbstractArray{T, 3}, Union{Blast.CMBLensingKernel, Blast.GalaxyKernel, Blast.ShearKernel}, Union{Blast.CMBLensingKernel, Blast.GalaxyKernel, Blast.ShearKernel}, Blast.BackgroundQuantities, AbstractVector, AbstractVector{T}}} where T","page":"API","title":"Blast.compute_Cℓ","text":"compute_Cℓ(w::AbstractArray{T, 3}, \n           ProbeA::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}, \n           ProbeB::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}, \n           BackgroundQuantities::BackgroundQuantities, \n           R::AbstractVector, \n           ℓ_list::AbstractArray{T,1} = Blast.ℓ) where T\n\nComputes the angular power spectrum Cℓ by performing two outer integrals over χ and R.  The Simpson quadrature rule is used for integration over χ, while Clenshaw-Curtis quadrature is used for R.\n\nArguments\n\nw::AbstractArray{T, 3}: A 3D array representing the projected matter densities, containing the inner integrals over k. The array dimensions are (ℓ, χ, R).\nProbeA::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}: The first cosmological probe kernel type.\nProbeB::Union{GalaxyKernel, ShearKernel, CMBLensingKernel}: The second cosmological probe kernel type.\nBackgroundQuantities::BackgroundQuantities: Contains background information, including χz_array for distances in the cosmology.\nR::AbstractVector: A 1D array representing the radial grid values for integration.\nℓ_list::AbstractArray{T,1}: An optional 1D array of angular multipole values, defaulting to the global variable Blast.ℓ, the list of ℓ values used for the precomputed part.\n\nReturns\n\nA 3D array Cℓ with dimensions (ℓ, i, j), where i and j represent the tomographic bins. The array contains the computed angular power spectrum coefficients for each combination of ℓ values and tomographic bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_Cℓ-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 4}, Blast.BackgroundQuantities, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T","page":"API","title":"Blast.compute_Cℓ","text":"compute_Cℓ(w::AbstractArray{T, 3}, \n           K::AbstractArray{T, 4}, \n           bkgq::BackgroundQuantities, \n           weights_χ::AbstractArray{T, 1}, \n           weights_R::AbstractArray{T, 1}, \n           ell_prefactor::AbstractArray{T,1}) where T\n\nComputes the angular power spectrum Cℓ by performing integrals over χ and R for a given set of inputs.\n\nArguments\n\nw::AbstractArray{T, 3}: A 3D array representing the projected matter densities, containing the inner integrals over k. The array dimensions are (ℓ, χ, R).\nK::AbstractArray{T, 4}: A 4D array representing the kernel product K[i, j, χ, R] for the given cosmological probes. It combines the effects of the probes and tomographic bin combinations.\nbkgq::BackgroundQuantities: Contains background information, including χz_array for distances in the cosmology.\nweights_χ::AbstractArray{T, 1}: A 1D array of weights for Simpson quadrature integration over χ.\nweights_R::AbstractArray{T, 1}: A 1D array of weights for Clenshaw-Curtis quadrature integration over R.\nell_prefactor::AbstractArray{T,1}: A 1D array of prefactors dependent on angular multipole values ℓ, combining with other components to form the power spectrum.\n\nReturns\n\nA 3D array Cℓ with dimensions (ℓ, i, j), where i and j represent the tomographic bins. The array contains the computed angular power spectrum coefficients for each combination of ℓ values and tomographic bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_adimensional_hubble_factor-Union{Tuple{T}, Tuple{T, Blast.FlatΛCDM}} where T","page":"API","title":"Blast.compute_adimensional_hubble_factor","text":"compute_adimensional_hubble_factor(z::T, cosmo::FlatΛCDM) -> T\n\nComputes the adimensional Hubble factor E(z) for a given redshift z, using the  cosmological parameters from a FlatΛCDM model. The analitycal expression is given by:\n\nE(z)=sqrtOmega_m(1+z)^3+Omega_r(1+z)^4+\nOmega_de(1+z)^3(1+w_0+w_a)exp(-3w_a fracz1+z)+Omega_k(1+z)^2\n\nParameters:\n\nz: Redshift at which to evaluate the Hubble factor.\ncosmo: A FlatΛCDM cosmological model containing parameters like Ωm, Ωr, Ωde, etc.\n\nReturns:\n\nE_z: The adimensional Hubble factor at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_adimensional_hubble_factor-Union{Tuple{T}, NTuple{7, T}} where T","page":"API","title":"Blast.compute_adimensional_hubble_factor","text":"compute_adimensional_hubble_factor(z::T, Ωm::T, Ωr::T, Ωde::T, Ωk::T, w0::T, wa::T) -> T\n\nComputes the adimensional Hubble factor E(z) given the redshift z and individual cosmological parameters. The analitycal expression is given by:\n\nE(z)=sqrtOmega_m(1+z)^3+Omega_r(1+z)^4+\nOmega_de(1+z)^3(1+w_0+w_a)exp(-3w_a fracz1+z)+Omega_k(1+z)^2\n\nParameters:\n\nz: Redshift at which to evaluate the Hubble factor.\nΩm: Matter density parameter.\nΩr: Radiation density parameter.\nΩde: Dark energy density parameter.\nΩk: Curvature density parameter.\nw0: Dark energy equation of state parameter at the present time.\nwa: Time evolution of the dark energy equation of state.\n\nReturns:\n\nE_z: The adimensional Hubble factor at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_hubble_factor","page":"API","title":"Blast.compute_hubble_factor","text":"compute_hubble_factor(z::T, cosmo::AbstractCosmology) -> T\n\nComputes the Hubble parameter H(z) at a given redshift z using the Hubble constant H0 and the adimensional  Hubble factor E(z).\n\nParameters:\n\nz: Redshift at which to compute the Hubble parameter.\ncosmo: A cosmological model that contains H0 and other necessary parameters.\n\nReturns:\n\nH_z: The Hubble parameter at redshift z.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_χ","page":"API","title":"Blast.compute_χ","text":"compute_χ(z::T, cosmo::AbstractCosmology) -> T\n\nComputes the comoving distance χ(z) to a given redshift z by numerically integrating  the inverse of the adimensional Hubble factor E(z):\n\nchi(z)=fraccH_0int_0^z fracdzE(z)\n\nParameters:\n\nz: Redshift up to which the comoving distance is computed.\ncosmo: A cosmological model containing the necessary parameters (e.g., Ωm, H0).\n\nReturns:\n\nχ_z: The comoving distance at redshift z in units of Mpc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.evaluate_background_quantities!","page":"API","title":"Blast.evaluate_background_quantities!","text":"evaluate_background_quantities!(grid::CosmologicalGrid, bg::BackgroundQuantities, cosmo::AbstractCosmology)\n\nPopulates the BackgroundQuantities struct with values for the Hubble parameter H(z) and comoving distance χ(z)  over the redshift range specified by the CosmologicalGrid.\n\nParameters:\n\ngrid: A grid specifying the redshift range over which to evaluate the background quantities.\nbg: A mutable struct where the computed H(z) and χ(z) values will be stored.\ncosmo: A cosmological model containing the necessary parameters (e.g., H0, Ωm).\n\nNotes:\n\nThis function modifies the BackgroundQuantities struct in place by filling the arrays with the computed values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.resample_redshifts","page":"API","title":"Blast.resample_redshifts","text":"resample_redshifts(bg::BackgroundQuantities, grid::AbstractCosmologicalGrid, new_χ::AbstractArray{T,1}) where T\n\nResamples redshift values corresponding to a new set of comoving distances using Akima interpolation.\n\nArguments\n\nbg::BackgroundQuantities: An object containing background cosmological quantities,  including the mapping between redshift (z) and comoving distance (χ).\ngrid::AbstractCosmologicalGrid: An object defining the range of redshifts (z_range)  and associated cosmological grid quantities.\nnew_χ::AbstractArray{T,1}: A 1D array of comoving distances for which corresponding redshift values are desired.\n\nReturns\n\nresampled_z::AbstractArray{T,1}: A 1D array of resampled redshift values corresponding to the input comoving distances new_χ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_kernel!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Blast.GalaxyKernel, AbstractVector{T}, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}} where T","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(nz::AbstractArray{T, 2}, Probe::GalaxyKernel, z::AbstractArray{T, 1},\n                bias::AbstractArray{T,1}, grid::CosmologicalGrid, bg::BackgroundQuantities, \n                cosmo::AbstractCosmology) where T\n\nComputes the galaxy clustering kernel based on a redshift distribution nz and stores it in the GalaxyKernel struct.  The kernel is defined as: \n\nW_g(chi) = fracH(z)cn(z)b(z)\n\nParameters:\n\nnz: A 2D array of type T where each row represents the redshift distribution of galaxies for a specific redshift bin.\nz: The redshift grid corresponding to the nz array.\nProbe: An instance of GalaxyKernel, in which the computed kernel values for each redshift bin will be stored.\nbias: A vector of size n_bins containing the constant value of the bias in each tomographic bin.\ngrid: A CosmologicalGrid object specifying the redshift range and grid points for kernel computation.\nbg: A struct containing arrays of Hubble parameter (Hz_array) and comoving distance (χz_array), precomputed over the grid.\ncosmo: An instance of a cosmological model used to calculate the background quantities if not already provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_kernel!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Blast.GalaxyKernel, AbstractMatrix{T}, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}} where T","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(nz::AbstractArray{T, 2}, Probe::GalaxyKernel, z::AbstractArray{T, 1},\n                bias::AbstractArray{T,2}, grid::CosmologicalGrid, bg::BackgroundQuantities, \n                cosmo::AbstractCosmology) where T\n\nComputes the galaxy clustering kernel based on a redshift distribution nz and stores it in the GalaxyKernel struct.  The kernel is defined as: \n\nW_g(chi) = fracH(z)cn(z)b(z)\n\nParameters:\n\nnz: A 2D array of type T where each row represents the redshift distribution of galaxies for a specific redshift bin.\nz: The redshift grid corresponding to the nz array.\nProbe: An instance of GalaxyKernel, in which the computed kernel values for each redshift bin will be stored.\nbias: A 2D array of type T where each row represents the value of the b(z) in each tomographic bin.\ngrid: A CosmologicalGrid object specifying the redshift range and grid points for kernel computation.\nbg: A struct containing arrays of Hubble parameter (Hz_array) and comoving distance (χz_array), precomputed over the grid.\ncosmo: An instance of a cosmological model used to calculate the background quantities if not already provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_kernel!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Blast.ShearKernel, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}} where T","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(nz::AbstractArray{T, 2}, Probe::ShearKernel, z::AbstractArray{T, 1},\n                grid::CosmologicalGrid, bg::BackgroundQuantities, \n                cosmo::AbstractCosmology) where T\n\nComputes the weak lensing shear kernel based on a redshift distribution nz and stores it in the ShearKernel struct.  The kernel is defined as: \n\nW_gamma(chi) = frac32fracH_0^2c^2Omega_m fracchia(chi)int_z(chi)^inftydzn(z)fracchi(z)-chichi(z)\n\nParameters:\n\nnz: A 2D array of type T where each row corresponds to the redshift distribution for a specific shear redshift bin.\nz: The redshift grid corresponding to the nz array.\nProbe: An instance of ShearKernel, where computed kernel values for each redshift bin will be stored.\ngrid: A CosmologicalGrid object defining the redshift range and grid points for kernel computation.\nbg: A struct containing precomputed Hubble parameter (Hz_array) and comoving distance (χz_array) arrays over the grid.\ncosmo: An instance of a cosmological model that provides background parameters needed for lensing kernel calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_kernel!-Tuple{Blast.CMBLensingKernel, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(Probe::CMBLensingKernel, \n                grid::CosmologicalGrid, bg::BackgroundQuantities, \n                cosmo::AbstractCosmology)\n\nComputes the CMB lensing kernel and stores it in the CMBLensingKernel struct. The kernel is defined as: \n\nW_kappa(chi) = frac32fracH_0^2c^2Omega_m fracchia(chi)fracchi^*-chichi^*\n\nwhere chi^* = chi(z_mathrmCMB = 1100)\n\nParameters:\n\nProbe: An instance of CMBLensingKernel to store the computed kernel values.\ngrid: A grid specifying the redshift range over which the kernel is computed.\nbg: A struct containing precomputed Hubble parameter and comoving distance values.\ncosmo: A cosmological model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.chebyshev_polynomials","page":"API","title":"Blast.chebyshev_polynomials","text":"chebyshev_polynomials(x::AbstractArray{T,1}, n_cheb::Int, z_min::T, z_max::T) where T\n\nComputes the Chebyshev polynomials T_n(x) up to a specified order for a given range of x.\n\nArguments\n\nx::AbstractArray{T,1}: An array of input values for which the Chebyshev polynomials will be evaluated.\nn_cheb::Int: The maximum order of Chebyshev polynomials to compute.\nz_min::T: The minimum value in the domain of x.\nz_max::T: The maximum value in the domain of x.\n\nReturns\n\nA 2D array where each row corresponds to a Chebyshev polynomial T_n(x)\n\nNotes\n\nScales x to the Chebyshev domain -1 1.\nRecurrence relation:\nT_0(x) = 1`\nT_1(x) = x\nT_n+1(x) = 2xT_n(x) - T_n-1(x) for n geq 2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.interpolate_power_spectrum","page":"API","title":"Blast.interpolate_power_spectrum","text":"interpolate_power_spectrum(pk::AbstractArray{T,2}, z_nodes::AbstractArray{T,1}, \n                           R::AbstractArray{T,1}, plan::FFTW.r2rFFTWPlan, \n                           bg::BackgroundQuantities, grid::AbstractCosmologicalGrid) where T\n\nInterpolates the power spectrum  P(z,k) to put it on the chi-R grid optimal for the algorithm. Returns the object P(k chi R). \n\nArguments\n\npk::AbstractArray{T,2}: A 2D array of power spectrum values. The function expects the first axis to be z, and the second one to be k.\nz_nodes::AbstractArray{T,1}: Redshift values corresponding to the first axis of pk.\nR::AbstractArray{T,1}: Values of R equiv chi_2chi_1.\nplan::FFTW.r2rFFTWPlan: FFTW plan for computing Chebyshev coefficients.\nbg::BackgroundQuantities: Background cosmological quantities. Contains the comoving distance values.\ngrid::AbstractCosmologicalGrid: Grid of cosmological quantities. Contains the redshift grid.\n\nReturns\n\nA 3D array of interpolated power spectrum values with dimensions (k chi R)\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.unequal_time_power_spectrum","page":"API","title":"Blast.unequal_time_power_spectrum","text":"unequal_time_power_spectrum(pk::AbstractArray{T,3}) where T\n\nTakes in input the power spectrum on the (k chi R) grid and implements the equation: \n\nP(kchi Rchi)=sqrtP(kchi)P(kRchi)\n\nwhich assumes that the quantities involved are perfectly correlated at different cosmic times.\n\nArguments\n\npk::AbstractArray{T,3}: A 3D array of power spectrum values on a grid (k chi R)\n\nReturns\n\nA 3D array with the same dimensions as pk.\n\n\n\n\n\n","category":"function"},{"location":"#Blast.jl","page":"Home","title":"Blast.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello, welcome to Blast.jl documentation! ","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sofia Chiarenza, PhD Student at Waterloo Centre for Astrophysics. Marco Bonici, PostDoctoral Researcher at Waterloo Centre for Astrophysics.","category":"page"},{"location":"alg/#The-algorithm","page":"The algorithm","title":"The algorithm","text":"","category":"section"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Blast.jl computes integrals of the form: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell)= N(ell) int_0^infty mathrmd chi_1 W_i^mathrmA(chi_1) int_0^infty mathrmd chi_2 W_j^mathrmB(chi_2) int_0^infty mathrmd k k^2 P_mathrmAB(k chi_1 chi_2) fracj_ell(k chi_1) j_ell(k chi_2)(k chi_1)^alpha (k chi_2)^beta","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Currently, Blast.jl supports two kinds of kernels:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Clustering: W_i^g(chi)=H(z)n_i(z)b_g(z), alpha = 0\nWeak Lensing: W_i^s(chi)= frac3H_0^2Omega_m2achi int_z^infty dz n_i(z)fracchi(z)-chichi(z), beta = 2","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The algorithm takes advantage of the useful properties of Chebyshev polynomials, using them as a basis for efficiently decomposing the 3D matter power spectrum P(kchi_1chi_2):","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Pleft(k chi_1 chi_2  thetaright) approx sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) T_n(k)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"This decomposition is advantageous for multiple reasons: first of all, the coefficients c_n(chi_1 chi_2) can be quickly obtained through a DFT. Moreover, the approximation of a function on the basis of the Chebyshev polynomials is the most accurate compared to any other method for fixed number of interpolation points (see e.g. Trefethen (2019)). Finally, this decomposition enables a clear separation of geometric and cosmological components in the integrals, simplifying the overall calculation. We can write:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"w_ell^mathrmABleft(chi_1 chi_2  thetaright) equiv sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) tildeT_n  ell^mathrmABleft(chi_1 chi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"where we defined: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"tildeT_n  ell^mathrmABleft(chi_1 chi_2right) equiv int_k_min ^k_max  mathrmd k f^mathrmAB(k) T_n(k) j_ellleft(k chi_1right) j_ellleft(kchi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"f^mathrmAB(k)= begincasesk^2  mathrmAB=g g  1  k^2  mathrmAB=s s  1  mathrmAB=g sendcases","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The dependence on the cosmological parameters is only present in the coefficients of the Chebyshev expansion of the power spectrum c_n(chi_1chi_2theta), while tildeT^mathrmAB_nell(chi_1chi_2) is cosmology-independent as it is the integral of the two Bessel functions against the Chebyshev polynomials. This is the key idea of the algorithm: the tildeT^mathrmAB_nell(chi_1chi_2) integrals are still challenging to compute for the presence of the Bessel functions, but they can be computed once-for-all.","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The last ingredient for a successful computation of the integral is a change of variable: introducing R equiv chi_2chi_1, we can switch from the chi_1-chi_2 to the chi-R basis, which allows for a better sampling of the regions that most contribute to the integral, i.e., when chi_1 approx chi_2 (or, equivalently,R approx 1). In these new variables, the integral becomes:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell) = int_0^infty mathrmd chi int_0^1 mathrmd R  chi left mathcalK_i^mathrmA(chi) mathcalK_j^mathrmB(R chi) + mathcalK_j^mathrmB(chi) mathcalK_i^mathrmA(R chi) right w_ell^mathrmAB(chi R chi)\n","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"mathcalK_i^mathrmA(chi)= begincasesK_i^mathrmA(chi)  text  for clustering   K_i^mathrmA(chi)  chi^2  text  for lensing endcases","category":"page"}]
}
