var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Blast.compute_T̃\nBlast.bessel_cheb_eval\nBlast.get_clencurt_weights\nBlast.get_clencurt_grid\nBlast.w_ell_tullio\nBlast.plan_fft\nBlast.fast_chebcoefs\nBlast.simpson_weight_array\nBlast.compute_Cℓ\nBlast.FlatΛCDM\nBlast.BackgroundQuantities\nBlast.AbstractCosmology\nBlast.AbstractBackgroundQuantities\nBlast.AbstractCosmologicalGrid\nBlast.ShearKernel\nBlast.AbstractCosmologicalProbes\nBlast.CosmologicalGrid\nBlast.CMBLensingKernel\nBlast.GalaxyKernel\nBlast.compute_adimensional_hubble_factor(z::T, cosmo::Blast.FlatΛCDM) where T\nBlast.compute_adimensional_hubble_factor(z::T, Ωm::T, Ωr::T, Ωde::T, Ωk::T, w0::T, wa::T) where T\nBlast.compute_hubble_factor\nBlast.compute_χ\nBlast.evaluate_background_quantities!\nBlast.compute_kernel!(nz::Vector{T}, Blast.AbstractCosmologicalProbes::Blast.GalaxyKernel, Blast.CosmologicalGrid::Blast.CosmologicalGrid, Blast.BackgroundQuantities::Blast.BackgroundQuantities, Blast.AbstractCosmology::Blast.AbstractCosmology) where T\nBlast.compute_kernel!(nz::Vector{T}, Blast.AbstractCosmologicalProbes::Blast.ShearKernel, Blast.CosmologicalGrid::Blast.CosmologicalGrid, Blast.BackgroundQuantities::Blast.BackgroundQuantities, Blast.AbstractCosmology::Blast.AbstractCosmology) where T\nBlast.compute_kernel!(Blast.AbstractCosmologicalProbes::Blast.CMBLensingKernel, Blast.CosmologicalGrid::Blast.CosmologicalGrid, Blast.BackgroundQuantities::Blast.BackgroundQuantities, Blast.AbstractCosmology::Blast.AbstractCosmology)","category":"page"},{"location":"api/#Blast.compute_T̃","page":"API","title":"Blast.compute_T̃","text":"compute_T̃(ℓ::Number, χ::AbstractArray, R::AbstractArray, kmin::Number, kmax::Number, β::Number; n_cheb::Int = 119, N::Int = 2^(15)+1)\n\nCompute integrals of the Bessels function and the Chebyshev polynomials. This is the precomputation part of the code.\n\nArguments\n\nℓ::Number: Multipole order\nχ::AbstractArray: Array containing values of the comoving distance. \nR::AbstractArray: Array containing values for the R=χ₁/χ₂ variable.\nkmin::Number and kmax::Number: Integration range in k.\nβ::Number: Exponent of the k dependence of the integral. This parameter depends on the combination of tracers: β=2,-2,0 for clustering, cosmic shear and the cross-correlation respectively.\nn_cheb::Int: Number of chebyshev polynomials used in the approximation of the power spectra.\nN::Int: Number of integration points in k.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.bessel_cheb_eval","page":"API","title":"Blast.bessel_cheb_eval","text":"bessel_cheb_eval(ℓ::Number, kmin::Number, kmax::Number, χ::AbstractArray, n_cheb::Int, N::Number)\n\nReturn the Chebyshev polynomials up to order 'n_cheb+1' and the Bessel function of order 'ℓ' evaluated on the grid of 'N' Chebyshev points in the interval ['kmin', 'kmax'] and on the specified 'χ' points. \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_weights","page":"API","title":"Blast.get_clencurt_weights","text":"get_clencurt_weights(kmin::Number, kmax::Number, N::Number)\n\nReturn the set of 'N' weights needed to perform the integration with the Clenshaw-Curtis quadrature rule. The weights are rescaled between 'kmin' and 'kmax'.  \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_grid","page":"API","title":"Blast.get_clencurt_grid","text":"get_clencurt_grid(kmin::Number, kmax::Number, N::Number)\n\nReturn the integration points in k. They are a set of 'N' Chebyshev points rescaled between 'kmin' and 'kmax'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.w_ell_tullio","page":"API","title":"Blast.w_ell_tullio","text":"w_ell_tullio(c::AbstractArray,T::AbstractArray)\n\nCompute the tensor contraction of the chebyshev coefficients of the power spectrum 'c' and the precomputed integrals 'T' to obtain the projected matter densities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.plan_fft","page":"API","title":"Blast.plan_fft","text":"plan_fft(vals::AbstractArray{<:Number,N})\n\nCreate an FFTW real-to-real (R2R) transformation plan for the first axis of a given multidimensional array vals.  In practise, the vals array is the power spectrum P(k,χ). The first axis should then contains the wavenumbers k, while the second axis contains the χ information.\n\nArguments\n\nvals::AbstractArray{<:Number, N}: The input array of any numerical type with N dimensions.\n\nReturns\n\np::FFTW.rFFTWPlan: A FFTW plan object for transforming vals with the appropriate real to real transformations. This plan can be applied using the * operator (e.g., transformed_vals = p * vals).\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.fast_chebcoefs","page":"API","title":"Blast.fast_chebcoefs","text":"fast_chebcoefs(vals::AbstractArray{<:Number,N}, plan::FFTW.r2rFFTWPlan)\n\nEfficiently compute the Chebyshev coefficients of a multidimensional array vals using an O(n log n) method. This method leverages FFT-based type-I Discrete Cosine Transform (DCT-I).\n\nArguments:\n\nvals::AbstractArray{<:Number,N}: A multidimensional array of values for which to compute the Chebyshev coefficients.\nplan::FFTW.r2rFFTWPlan: A FFTW plan object for transforming vals with the appropriate real to real transformations. This plan is applied using the * operator (e.g., transformed_vals = p * vals) and performs the DCT of the vals array along the first axis.\n\nReturns:\n\ncoefs: An array of the same size as vals, containing the computed Chebyshev coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.simpson_weight_array","page":"API","title":"Blast.simpson_weight_array","text":"simpson_weight_array(n::Int; T=Float64)\n\nComputes the weights for the Simpson quadrature rule for numerical integration based on the input number of points n.\n\nArguments\n\nn::Int: The number of points (must be at least 2).\nT: (optional) The type of the output array. Defaults to Float64.\n\nReturns\n\nAn array of length n with the weights of type T for the Simpson quadrature rule.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_Cℓ","page":"API","title":"Blast.compute_Cℓ","text":"compute_Cℓ(w::AbstractArray{T, 3}, K::AbstractArray{T, 4}, χ::AbstractVector, R::AbstractVector)\n\nComputes the Cℓ's by performing the two outer integrals in χ and R. The integration in χ is performed using the Simpson quadrature rule, while the integration in R is performed using the Clenshaw-Curtis quadrature rule.\n\nArguments\n\nw::AbstractArray{T, 3}: A 3D array representing the projected matter densities, i.e. the inner integrals in k. The three axis are (ℓ, χ, R).\nK::AbstractArray{T, 4}: A 4D array representing the kernel function, with dimensions (i,j,χ,R). i and j are the tomographic bins.\nχ::AbstractVector: A 1D array containing the χ values.\nR::AbstractVector: A 1D array containing the R values.\n\nReturns\n\nA multi-dimensional array Cℓ with axis (ℓ, i, j) containing the angular power spectrum coefficients in every combination of tomographic bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.FlatΛCDM","page":"API","title":"Blast.FlatΛCDM","text":"FlatΛCDM{T}(; w0 = -1.0, wa = 0.0, H0 = 67.27, Ωm = 0.3156, Ωb = 0.0492, \n    Ωde = 0.6844, As = 2.12107e-9, σ8 = 0.816, Ωk = 0.0, Ωr = 0.0, ns = 0.9645\n)\n\nParameters:\n\nw0: Dark energy equation of state parameter at present time (default: -1).\nwa: Time evolution of the dark energy equation of state (default: 0).\nH0: Hubble constant in km/s/Mpc (default: 67.27).\nΩm: Matter density parameter (default: 0.3156).\nΩb: Baryon density parameter (default: 0.0492).\nΩde: Dark energy density parameter (default: 0.6844).\nAs: Scalar amplitude of the primordial power spectrum (default: 2.12107e-9).\nσ8: Root-mean-square density fluctuation in spheres of radius 8 Mpc (default: 0.816).\nΩk: Curvature density parameter (default: 0, for flat universe).\nΩr: Radiation density parameter (default: 0, since radiation is negligible at low redshift).\nns: Scalar spectral index (default: 0.9645).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.BackgroundQuantities","page":"API","title":"Blast.BackgroundQuantities","text":"BackgroundQuantities{T}(; Hz_array, χz_array)\n\nParameters:\n\nHz_array: Array of Hubble parameter values, evaluated on a grid of redshift values (default: zeros(500)).\nχz_array: Array of comoving distance values, evaluated on a grid of redshift values (default: zeros(500)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmology","page":"API","title":"Blast.AbstractCosmology","text":"AbstractCosmology{T}\n\nAn abstract type representing a general cosmological model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractBackgroundQuantities","page":"API","title":"Blast.AbstractBackgroundQuantities","text":"AbstractBackgroundQuantities{T}\n\nAn abstract type for background quantities in cosmology, such as the Hubble parameter (H), comoving distance (χ),  and the growth factor (D).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmologicalGrid","page":"API","title":"Blast.AbstractCosmologicalGrid","text":"AbstractCosmologicalGrid{T}\n\nAn abstract type representing a grid on which cosmological quantities are evaluated.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.ShearKernel","page":"API","title":"Blast.ShearKernel","text":"ShearKernel{T} <: AbstractCosmologicalProbes{T}\n\nParameters:\n\nKernel: A vector of type T that holds the kernel values (default: zeros(500)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.AbstractCosmologicalProbes","page":"API","title":"Blast.AbstractCosmologicalProbes","text":"AbstractCosmologicalProbes{T}\n\nAn abstract type for the shear, clustering and CMB lensing kernels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.CosmologicalGrid","page":"API","title":"Blast.CosmologicalGrid","text":"CosmologicalGrid{T}(; z_range, k_range)\n\nParameters:\n\nz_range: Array of redshift values where quantities like the Hubble parameter are evaluated (default: LinRange(0.001, 2.5, 300)).\nk_range: Array of wavenumbers for evaluating power spectra or other k-dependent quantities (default: LogSpaced(1e-5, 50, 1000)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.CMBLensingKernel","page":"API","title":"Blast.CMBLensingKernel","text":"CMBLensingKernel{T} <: AbstractCosmologicalProbes{T}\n\nParameters:\n\nKernel: A vector of type T that holds the kernel values (default: zeros(500)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.GalaxyKernel","page":"API","title":"Blast.GalaxyKernel","text":"GalaxyKernel{T} <: AbstractCosmologicalProbes{T}\n\nParameters\n\nKernel::Vector{T}: A vector of type T that holds the kernel values (default: zeros(500)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Blast.compute_adimensional_hubble_factor-Union{Tuple{T}, Tuple{T, Blast.FlatΛCDM}} where T","page":"API","title":"Blast.compute_adimensional_hubble_factor","text":"compute_adimensional_hubble_factor(z::T, cosmo::FlatΛCDM) -> T\n\nComputes the adimensional Hubble factor E(z) for a given redshift z, using the  cosmological parameters from a FlatΛCDM model.\n\nParameters:\n\nz: Redshift at which to evaluate the Hubble factor.\ncosmo: A FlatΛCDM cosmological model containing parameters like Ωm, Ωr, Ωde, etc.\n\nReturns:\n\nE_z: The adimensional Hubble factor at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_adimensional_hubble_factor-Union{Tuple{T}, NTuple{7, T}} where T","page":"API","title":"Blast.compute_adimensional_hubble_factor","text":"compute_adimensional_hubble_factor(z::T, Ωm::T, Ωr::T, Ωde::T, Ωk::T, w0::T, wa::T) -> T\n\nComputes the adimensional Hubble factor E(z) given the redshift z and individual cosmological parameters.\n\nParameters:\n\nz: Redshift at which to evaluate the Hubble factor.\nΩm: Matter density parameter.\nΩr: Radiation density parameter.\nΩde: Dark energy density parameter.\nΩk: Curvature density parameter.\nw0: Dark energy equation of state parameter at the present time.\nwa: Time evolution of the dark energy equation of state.\n\nReturns:\n\nE_z: The adimensional Hubble factor at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_hubble_factor","page":"API","title":"Blast.compute_hubble_factor","text":"compute_hubble_factor(z::T, AbstractCosmology::AbstractCosmology) -> T\n\nComputes the Hubble parameter H(z) at a given redshift z using the Hubble constant H0 and the adimensional  Hubble factor E(z).\n\nParameters:\n\nz: Redshift at which to compute the Hubble parameter.\nAbstractCosmology: A cosmological model that contains H0 and other necessary parameters.\n\nReturns:\n\nH_z: The Hubble parameter at redshift z.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_χ","page":"API","title":"Blast.compute_χ","text":"compute_χ(z::T, AbstractCosmology::AbstractCosmology) -> T\n\nComputes the comoving distance χ(z) to a given redshift z by numerically integrating  the inverse of the adimensional Hubble factor E(z).\n\nParameters:\n\nz: Redshift up to which the comoving distance is computed.\nAbstractCosmology: A cosmological model containing the necessary parameters (e.g., Ωm, H0).\n\nReturns:\n\nχ_z: The comoving distance at redshift z in units of Mpc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.evaluate_background_quantities!","page":"API","title":"Blast.evaluate_background_quantities!","text":"evaluate_background_quantities!(CosmologicalGrid::CosmologicalGrid, BackgroundQuantities::BackgroundQuantities, AbstractCosmology::AbstractCosmology)\n\nPopulates the BackgroundQuantities struct with values for the Hubble parameter H(z) and comoving distance χ(z)  over the redshift range specified by the CosmologicalGrid.\n\nParameters:\n\nCosmologicalGrid: A grid specifying the redshift range over which to evaluate the background quantities.\nBackgroundQuantities: A mutable struct where the computed H(z) and χ(z) values will be stored.\nAbstractCosmology: A cosmological model containing the necessary parameters (e.g., H0, Ωm).\n\nNotes:\n\nThis function modifies the BackgroundQuantities struct in place by filling the arrays with the computed values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_kernel!-Union{Tuple{T}, Tuple{Vector{T}, Blast.GalaxyKernel, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}} where T","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(nz::Vector{T}, AbstractCosmologicalProbes::GalaxyKernel, \n                CosmologicalGrid::CosmologicalGrid, BackgroundQuantities::BackgroundQuantities, \n                AbstractCosmology::AbstractCosmology) where T\n\nComputes the galaxy clustering kernel based on a redshift distribution nz and stores it in the GalaxyKernel struct.\n\nParameters:\n\nnz: Redshift distribution of galaxies, as a vector of type T.\nAbstractCosmologicalProbes: An instance of GalaxyKernel to store the computed kernel values.\nCosmologicalGrid: A grid specifying the redshift range over which the kernel is computed.\nBackgroundQuantities: A struct containing precomputed Hubble parameter and comoving distance values.\nAbstractCosmology: A cosmological model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_kernel!-Union{Tuple{T}, Tuple{Vector{T}, Blast.ShearKernel, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}} where T","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(nz::Vector{T}, AbstractCosmologicalProbes::ShearKernel, \n                CosmologicalGrid::CosmologicalGrid, BackgroundQuantities::BackgroundQuantities, \n                AbstractCosmology::AbstractCosmology) where T\n\nComputes the weak lensing shear kernel based on a redshift distribution nz and stores it in the ShearKernel struct.\n\nParameters:\n\nnz: Redshift distribution of galaxies, as a vector of type T.\nAbstractCosmologicalProbes: An instance of ShearKernel to store the computed kernel values.\nCosmologicalGrid: A grid specifying the redshift range over which the kernel is computed.\nBackgroundQuantities: A struct containing precomputed Hubble parameter and comoving distance values.\nAbstractCosmology: A cosmological model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Blast.compute_kernel!-Tuple{Blast.CMBLensingKernel, Blast.CosmologicalGrid, Blast.BackgroundQuantities, Blast.AbstractCosmology}","page":"API","title":"Blast.compute_kernel!","text":"compute_kernel!(AbstractCosmologicalProbes::CMBLensingKernel, \n                CosmologicalGrid::CosmologicalGrid, BackgroundQuantities::BackgroundQuantities, \n                AbstractCosmology::AbstractCosmology)\n\nComputes the CMB lensing kernel and stores it in the CMBLensingKernel struct.\n\nParameters:\n\nAbstractCosmologicalProbes: An instance of CMBLensingKernel to store the computed kernel values.\nCosmologicalGrid: A grid specifying the redshift range over which the kernel is computed.\nBackgroundQuantities: A struct containing precomputed Hubble parameter and comoving distance values.\nAbstractCosmology: A cosmological model.\n\n\n\n\n\n","category":"method"},{"location":"#Blast.jl","page":"Home","title":"Blast.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello, welcome to Blast.jl documentation! ","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sofia Chiarenza, PhD student at Waterloo Centre for Astrophysics.","category":"page"},{"location":"alg/#The-algorithm","page":"The algorithm","title":"The algorithm","text":"","category":"section"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Blast.jl computes integrals of the form: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell)= N(ell) int_0^infty mathrmd chi_1 W_i^mathrmA(chi_1) int_0^infty mathrmd chi_2 W_j^mathrmB(chi_2) int_0^infty mathrmd k k^2 P_mathrmAB(k chi_1 chi_2) fracj_ell(k chi_1) j_ell(k chi_2)(k chi_1)^alpha (k chi_2)^beta","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Currently, Blast.jl supports two kinds of kernels:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Clustering: W_i^g(chi)=H(z)n_i(z)b_g(z), alpha = 0\nWeak Lensing: W_i^s(chi)= frac3H_0^2Omega_m2achi int_z^infty dz n_i(z)fracchi(z)-chichi(z), beta = 2","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The algorithm takes advantage of the useful properties of Chebyshev polynomials, using them as a basis for efficiently decomposing the 3D matter power spectrum P(kchi_1chi_2):","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Pleft(k chi_1 chi_2  thetaright) approx sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) T_n(k)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"This decomposition is advantageous for multiple reasons: first of all, the coefficients c_n(chi_1 chi_2) can be quickly obtained through a DFT. Moreover, the approximation of a function on the basis of the Chebyshev polynomials is the most accurate compared to any other method for fixed number of interpolation points (see e.g. Trefethen (2019)). Finally, this decomposition enables a clear separation of geometric and cosmological components in the integrals, simplifying the overall calculation. We can write:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"w_ell^mathrmABleft(chi_1 chi_2  thetaright) equiv sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) tildeT_n  ell^mathrmABleft(chi_1 chi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"where we defined: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"tildeT_n  ell^mathrmABleft(chi_1 chi_2right) equiv int_k_min ^k_max  mathrmd k f^mathrmAB(k) T_n(k) j_ellleft(k chi_1right) j_ellleft(kchi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"f^mathrmAB(k)= begincasesk^2  mathrmAB=g g  1  k^2  mathrmAB=s s  1  mathrmAB=g sendcases","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The dependence on the cosmological parameters is only present in the coefficients of the Chebyshev expansion of the power spectrum c_n(chi_1chi_2theta), while tildeT^mathrmAB_nell(chi_1chi_2) is cosmology-independent as it is the integral of the two Bessel functions against the Chebyshev polynomials. This is the key idea of the algorithm: the tildeT^mathrmAB_nell(chi_1chi_2) integrals are still challenging to compute for the presence of the Bessel functions, but they can be computed once-for-all.","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The last ingredient for a successful computation of the integral is a change of variable: introducing R equiv chi_2chi_1, we can switch from the chi_1-chi_2 to the chi-R basis, which allows for a better sampling of the regions that most contribute to the integral, i.e., when chi_1 approx chi_2 (or, equivalently,R approx 1). In these new variables, the integral becomes:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell) = int_0^infty mathrmd chi int_0^1 mathrmd R  chi left mathcalK_i^mathrmA(chi) mathcalK_j^mathrmB(R chi) + mathcalK_j^mathrmB(chi) mathcalK_i^mathrmA(R chi) right w_ell^mathrmAB(chi R chi)\n","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"mathcalK_i^mathrmA(chi)= begincasesK_i^mathrmA(chi)  text  for clustering   K_i^mathrmA(chi)  chi^2  text  for lensing endcases","category":"page"}]
}
