var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Blast.compute_T̃\nBlast.bessel_cheb_eval\nBlast.get_clencurt_weights\nBlast.get_clencurt_grid\nBlast.w_ell_tullio\nBlast.plan_fft\nBlast.fast_chebcoefs\nBlast.simpson_weight_array\nBlast.compute_Cℓ","category":"page"},{"location":"api/#Blast.compute_T̃","page":"API","title":"Blast.compute_T̃","text":"compute_T̃(ℓ::Number, χ::AbstractArray, R::AbstractArray, kmin::Number, kmax::Number, β::Number; n_cheb::Int = 119, N::Int = 2^(15)+1)\n\nCompute integrals of the Bessels function and the Chebyshev polynomials. This is the precomputation part of the code.\n\nArguments\n\nℓ::Number: Multipole order\nχ::AbstractArray: Array containing values of the comoving distance. \nR::AbstractArray: Array containing values for the R=χ₁/χ₂ variable.\nkmin::Number and kmax::Number: Integration range in k.\nβ::Number: Exponent of the k dependence of the integral. This parameter depends on the combination of tracers: β=2,-2,0 for clustering, cosmic shear and the cross-correlation respectively.\nn_cheb::Int: Number of chebyshev polynomials used in the approximation of the power spectra.\nN::Int: Number of integration points in k.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.bessel_cheb_eval","page":"API","title":"Blast.bessel_cheb_eval","text":"bessel_cheb_eval(ℓ::Number, kmin::Number, kmax::Number, χ::AbstractArray, n_cheb::Int, N::Number)\n\nReturn the Chebyshev polynomials up to order 'n_cheb+1' and the Bessel function of order 'ℓ' evaluated on the grid of 'N' Chebyshev points in the interval ['kmin', 'kmax'] and on the specified 'χ' points. \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_weights","page":"API","title":"Blast.get_clencurt_weights","text":"get_clencurt_weights(kmin::Number, kmax::Number, N::Number)\n\nReturn the set of 'N' weights needed to perform the integration with the Clenshaw-Curtis quadrature rule. The weights are rescaled between 'kmin' and 'kmax'.  \n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.get_clencurt_grid","page":"API","title":"Blast.get_clencurt_grid","text":"get_clencurt_grid(kmin::Number, kmax::Number, N::Number)\n\nReturn the integration points in k. They are a set of 'N' Chebyshev points rescaled between 'kmin' and 'kmax'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.w_ell_tullio","page":"API","title":"Blast.w_ell_tullio","text":"w_ell_tullio(c::AbstractArray,T::AbstractArray)\n\nCompute the tensor contraction of the chebyshev coefficients of the power spectrum 'c' and the precomputed integrals 'T' to obtain the projected matter densities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.plan_fft","page":"API","title":"Blast.plan_fft","text":"plan_fft(vals::AbstractArray{<:Number,N})\n\nCreate an FFTW real-to-real (R2R) transformation plan for the first axis of a given multidimensional array vals.  In practise, the vals array is the power spectrum P(k,χ). The first axis should then contains the wavenumbers k, while the second axis contains the χ information.\n\nArguments\n\nvals::AbstractArray{<:Number, N}: The input array of any numerical type with N dimensions.\n\nReturns\n\np::FFTW.rFFTWPlan: A FFTW plan object for transforming vals with the appropriate real to real transformations. This plan can be applied using the * operator (e.g., transformed_vals = p * vals).\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.fast_chebcoefs","page":"API","title":"Blast.fast_chebcoefs","text":"fast_chebcoefs(vals::AbstractArray{<:Number,N}, plan::FFTW.r2rFFTWPlan)\n\nEfficiently compute the Chebyshev coefficients of a multidimensional array vals using an O(n log n) method. This method leverages FFT-based type-I Discrete Cosine Transform (DCT-I).\n\nArguments:\n\nvals::AbstractArray{<:Number,N}: A multidimensional array of values for which to compute the Chebyshev coefficients.\nplan::FFTW.r2rFFTWPlan: A FFTW plan object for transforming vals with the appropriate real to real transformations. This plan is applied using the * operator (e.g., transformed_vals = p * vals) and performs the DCT of the vals array along the first axis.\n\nReturns:\n\ncoefs: An array of the same size as vals, containing the computed Chebyshev coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.simpson_weight_array","page":"API","title":"Blast.simpson_weight_array","text":"simpson_weight_array(n::Int; T=Float64)\n\nComputes the weights for the Simpson quadrature rule for numerical integration based on the input number of points n.\n\nArguments\n\nn::Int: The number of points (must be at least 2).\nT: (optional) The type of the output array. Defaults to Float64.\n\nReturns\n\nAn array of length n with the weights of type T for the Simpson quadrature rule.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blast.compute_Cℓ","page":"API","title":"Blast.compute_Cℓ","text":"compute_Cℓ(w::AbstractArray{T, 3}, K::AbstractArray{T, 4}, χ::AbstractVector, R::AbstractVector)\n\nComputes the Cℓ's by performing the two outer integrals in χ and R. The integration in χ is performed using the Simpson quadrature rule, while the integration in R is performed using the Clenshaw-Curtis quadrature rule.\n\nArguments\n\nw::AbstractArray{T, 3}: A 3D array representing the projected matter densities, i.e. the inner integrals in k. The three axis are (ℓ, χ, R).\nK::AbstractArray{T, 4}: A 4D array representing the kernel function, with dimensions (i,j,χ,R). i and j are the tomographic bins.\nχ::AbstractVector: A 1D array containing the χ values.\nR::AbstractVector: A 1D array containing the R values.\n\nReturns\n\nA multi-dimensional array Cℓ with axis (ℓ, i, j) containing the angular power spectrum coefficients in every combination of tomographic bins.\n\n\n\n\n\n","category":"function"},{"location":"#Blast.jl","page":"Home","title":"Blast.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello, welcome to Blast.jl documentation! ","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sofia Chiarenza, PhD student at Waterloo Centre for Astrophysics.","category":"page"},{"location":"alg/#The-algorithm","page":"The algorithm","title":"The algorithm","text":"","category":"section"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Blast.jl computes integrals of the form: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell)= N(ell) int_0^infty mathrmd chi_1 W_i^mathrmA(chi_1) int_0^infty mathrmd chi_2 W_j^mathrmB(chi_2) int_0^infty mathrmd k k^2 P_mathrmAB(k chi_1 chi_2) fracj_ell(k chi_1) j_ell(k chi_2)(k chi_1)^alpha (k chi_2)^beta","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Currently, Blast.jl supports two kinds of kernels:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Clustering: W_i^g(chi)=H(z)n_i(z)b_g(z), alpha = 0\nWeak Lensing: W_i^s(chi)= frac3H_0^2Omega_m2achi int_z^infty dz n_i(z)fracchi(z)-chichi(z), beta = 2","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The algorithm takes advantage of the useful properties of Chebyshev polynomials, using them as a basis for efficiently decomposing the 3D matter power spectrum P(kchi_1chi_2):","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"Pleft(k chi_1 chi_2  thetaright) approx sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) T_n(k)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"This decomposition is advantageous for multiple reasons: first of all, the coefficients c_n(chi_1 chi_2) can be quickly obtained through a DFT. Moreover, the approximation of a function on the basis of the Chebyshev polynomials is the most accurate compared to any other method for fixed number of interpolation points (see e.g. Trefethen (2019)). Finally, this decomposition enables a clear separation of geometric and cosmological components in the integrals, simplifying the overall calculation. We can write:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"w_ell^mathrmABleft(chi_1 chi_2  thetaright) equiv sum_n=0^n_max  c_nleft(chi_1 chi_2  thetaright) tildeT_n  ell^mathrmABleft(chi_1 chi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"where we defined: ","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"tildeT_n  ell^mathrmABleft(chi_1 chi_2right) equiv int_k_min ^k_max  mathrmd k f^mathrmAB(k) T_n(k) j_ellleft(k chi_1right) j_ellleft(kchi_2right)","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"f^mathrmAB(k)= begincasesk^2  mathrmAB=g g  1  k^2  mathrmAB=s s  1  mathrmAB=g sendcases","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The dependence on the cosmological parameters is only present in the coefficients of the Chebyshev expansion of the power spectrum c_n(chi_1chi_2theta), while tildeT^mathrmAB_nell(chi_1chi_2) is cosmology-independent as it is the integral of the two Bessel functions against the Chebyshev polynomials. This is the key idea of the algorithm: the tildeT^mathrmAB_nell(chi_1chi_2) integrals are still challenging to compute for the presence of the Bessel functions, but they can be computed once-for-all.","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"The last ingredient for a successful computation of the integral is a change of variable: introducing R equiv chi_2chi_1, we can switch from the chi_1-chi_2 to the chi-R basis, which allows for a better sampling of the regions that most contribute to the integral, i.e., when chi_1 approx chi_2 (or, equivalently,R approx 1). In these new variables, the integral becomes:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"C_ij^mathrmAB(ell) = int_0^infty mathrmd chi int_0^1 mathrmd R  chi left mathcalK_i^mathrmA(chi) mathcalK_j^mathrmB(R chi) + mathcalK_j^mathrmB(chi) mathcalK_i^mathrmA(R chi) right w_ell^mathrmAB(chi R chi)\n","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"with:","category":"page"},{"location":"alg/","page":"The algorithm","title":"The algorithm","text":"mathcalK_i^mathrmA(chi)= begincasesK_i^mathrmA(chi)  text  for clustering   K_i^mathrmA(chi)  chi^2  text  for lensing endcases","category":"page"}]
}
